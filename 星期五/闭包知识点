### 闭包知识点总结
### 一·闭包作用域

###### 1.创建函数

*  a）开辟一个堆内存
*  b）把函数体内的代码当做字符串存入进去
*  c）把堆内存的地址赋值给函数名
*  函数在哪创建的，它执行的时候所需要查找的上级作用域就是谁

###### 2.函数执行


* 形成一个全新的私有作用域，执行上下文，私有栈内存，（执行一次形成一个，多个之间不会互相影响）
* 形参赋值&变量提升
* 代码执行（把所属的堆内存的中的代码拿出来一行行执行）
* 遇到一个变量首先看他是否为私有变量（形参和在私有作用域中声明的变量是私有变量），是私有变量的就操作自己的私有变量即可，不是私有变量的就向上级的作用域中查找...一直找到全局作用域为止，=》作用域链查找机制
* 私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来了。这种机制就是闭包保护机制

###### 3.关于堆栈内存释放的问题

* 函数执行就会形成栈内存（从内存中分配一块空间），如果内存都不释放，很容易就会导致栈溢出，（内存爆满，电脑容易卡死），堆栈内存的释放是学习js的核心知识点之一
* 主要有一个引用类型的值，就会有一个堆内存

###### 堆内存的释放问题


```javascript
堆内存的产生 => 创建一个引用类型的值就会产生堆内存

如果当前创建的堆内存不被其他东西所占用了（浏览器会在空闲的时候，浏览器会在空闲的时候，查找每一个内存的引用状况，不被占用的，都会自己给回收掉）

let obj={
	name:"kirk"
}
let cc=obj；
//此时obj和cc都占用着对象的堆内存，想要释放堆内存，需要手动手动解除变量和值得关联
//解除
obj=null；
oop=null；
```
###### 栈内存的释放
```javascript
栈内存的形成
//打开浏览器形成的全局作用域是栈内存     
//手动执行函数的私有作用域是栈内存		
//基于es6中的let和const形成的块级作用域也是栈内存

//栈内存的销毁
全局作用域：关掉页面的时候才会销毁
私有栈内存：
1：一般情况下，函数执行完成，形成的私有栈内存就会被销毁释放掉
2：但是一旦占内存中的某个东西被（一般都是堆地址），被私有作用域以外的时候给占用了，则当前私有栈内存不能被立即释放销毁（私有作用域中的私有变量等信息也保留下来了）

//例子🌰
function x(){
	return  function(){
		//....
	}	
}
let g=x();//g占用了x执行形成的栈内存中的一个东西（返回小函数形成的堆），则x执行形成的栈内存不能被释放了。
//释放：让g=null，没人占用了，就释放掉了
//市面上的闭包：函数执行形成不能被释放掉的私有栈内存，这样的才是闭包
```

###### 练习题：

```javascript
var i=5;
function fn(i){
	return function(n){
		console.log(n+(++i));
	}
};
var f=fn(1);
f(2);  //=> 4
fn(3)(4);  //=>8
fn(5)(6);  //=>12
f(7);  //=>10
console.log(i);   //=>5
```
解析：
==这里面重点说下f(7),由于var f=fn(1)，使得fn内部的作用域始终得以保留，内部的i值也是被保留的，在上面fn(2)的时候，i已经从1=>2，所以再当f(7)的时候，i是从2=>3,结果就相当于7+3=10；要记住，被使用的部分保留作用域，其他的执行完了进行销毁。==

### 二、闭包的保护机制
闭包的两个作用：1.保护；2.保存
a）：jquery前端经典的框架类库，提供了大量的方法供开发人员使用；juqery为了防止用户自定义方法变量和类库中的方法冲突重名，就采用的闭包，防止冲突，防止全局变量污染。


```javascript
	//源码中有一段通过给window添加属性，让内部的暴露在全局，方便使用
	window.jquery = window.$ = JQuery
```

真是项目中一般的都会把自己写的代码放到闭包中去，防止自己的代码和别人的代码造成冲突，原生js中一般这么写：


```javascript
var xxx=(function ( )
	{
	//自己写的代码都放到里面去
	return xxx;
	} )()
```

==从性能角度来说应该尽量较少对闭包的使用从而减少（因为闭包会产生不释放的栈内存，过多的使用容易导致性能降低或内存溢出）==

	


